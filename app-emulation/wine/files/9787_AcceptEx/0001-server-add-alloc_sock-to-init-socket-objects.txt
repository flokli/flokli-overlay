diff --git a/server/sock.c b/server/sock.c
index 9cd0fc2..d6aa97c 100644
--- a/server/sock.c
+++ b/server/sock.c
@@ -593,6 +593,31 @@ static void sock_destroy( struct object *obj )
     }
 }
 
+static struct sock *alloc_sock(void)
+{
+    struct sock *sock;
+    if (!(sock = alloc_object( &sock_ops )))
+        return NULL;
+
+    sock->state = 0;
+    sock->mask    = 0;
+    sock->hmask   = 0;
+    sock->pmask   = 0;
+    sock->polling = 0;
+    sock->flags   = 0;
+    sock->type    = 0;
+    sock->family  = 0;
+    sock->event   = NULL;
+    sock->window  = 0;
+    sock->message = 0;
+    sock->wparam  = 0;
+    sock->deferred = NULL;
+    sock->read_q  = NULL;
+    sock->write_q = NULL;
+
+    return sock;
+}
+
 /* create a new and unconnected socket */
 static struct object *create_socket( int family, int type, int protocol, unsigned int flags )
 {
@@ -608,26 +633,15 @@ static struct object *create_socket( int family, int type, int protocol, unsigne
         return NULL;
     }
     fcntl(sockfd, F_SETFL, O_NONBLOCK); /* make socket nonblocking */
-    if (!(sock = alloc_object( &sock_ops )))
+    if (!(sock = alloc_sock()))
     {
         close( sockfd );
         return NULL;
     }
     sock->state = (type != SOCK_STREAM) ? (FD_READ|FD_WRITE) : 0;
-    sock->mask    = 0;
-    sock->hmask   = 0;
-    sock->pmask   = 0;
-    sock->polling = 0;
     sock->flags   = flags;
     sock->type    = type;
     sock->family  = family;
-    sock->event   = NULL;
-    sock->window  = 0;
-    sock->message = 0;
-    sock->wparam  = 0;
-    sock->deferred = NULL;
-    sock->read_q  = NULL;
-    sock->write_q = NULL;
     memset( sock->errors, 0, sizeof(sock->errors) );
     if (!(sock->fd = create_anonymous_fd( &sock_fd_ops, sockfd, &sock->obj,
                             (flags & WSA_FLAG_OVERLAPPED) ? 0 : FILE_SYNCHRONOUS_IO_NONALERT )))
@@ -672,7 +686,7 @@ static struct sock *accept_socket( obj_handle_t handle )
             release_object( sock );
             return NULL;
         }
-        if (!(acceptsock = alloc_object( &sock_ops )))
+        if (!(acceptsock = alloc_sock()))
         {
             close( acceptfd );
             release_object( sock );
@@ -685,20 +699,12 @@ static struct sock *accept_socket( obj_handle_t handle )
         if (sock->state & FD_WINE_NONBLOCKING)
             acceptsock->state |= FD_WINE_NONBLOCKING;
         acceptsock->mask    = sock->mask;
-        acceptsock->hmask   = 0;
-        acceptsock->pmask   = 0;
-        acceptsock->polling = 0;
         acceptsock->type    = sock->type;
         acceptsock->family  = sock->family;
-        acceptsock->event   = NULL;
         acceptsock->window  = sock->window;
         acceptsock->message = sock->message;
-        acceptsock->wparam  = 0;
         if (sock->event) acceptsock->event = (struct event *)grab_object( sock->event );
-        acceptsock->flags = sock->flags;
-        acceptsock->deferred = NULL;
-        acceptsock->read_q  = NULL;
-        acceptsock->write_q = NULL;
+        acceptsock->flags   = sock->flags;
         memset( acceptsock->errors, 0, sizeof(acceptsock->errors) );
         if (!(acceptsock->fd = create_anonymous_fd( &sock_fd_ops, acceptfd, &acceptsock->obj,
                                                     get_fd_options( sock->fd ) )))
